{"version":3,"sources":["webpack://aegis-app/./src/domain/utils.js","webpack://aegis-app/./node_modules/nanoid/index.js","webpack://aegis-app/./node_modules/nanoid/url-alphabet/index.js"],"names":["compose","funcs","initVal","reduceRight","val","func","composeAsync","then","Promise","resolve","asyncPipe","obj","reduce","o","f","passwd","process","env","ENCRYPTION_PWD","algo","key","crypto","String","iv","Buffer","alloc","encrypt","text","cipher","encrypted","update","decrypt","cipherText","console","log","decipher","decrypted","hash","data","digest","uuid","nanoid","makeArray","v","Array","isArray","makeObject","prop","p","c","async","promise","result","ok","object","asObject","asArray","error"],"mappings":"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","file":"src_domain_utils_js.js","sourcesContent":["'use strict'\n\nimport crypto from 'crypto'\nimport { nanoid } from 'nanoid'\n\nexport function compose (...funcs) {\n  return function (initVal) {\n    return funcs.reduceRight((val, func) => func(val), initVal)\n  }\n}\n\nexport function composeAsync (...funcs) {\n  return function (initVal) {\n    return funcs.reduceRight(\n      (val, func) => val.then(func),\n      Promise.resolve(initVal)\n    )\n  }\n}\n\n/**\n * @callback pipeFn\n * @param {object} obj - the object to compose\n * @returns {object} - the composed object\n */\n\n/**\n * @param {pipeFn} func\n */\nexport const asyncPipe = (...func) => obj =>\n  func.reduce((o, f) => o.then(f), Promise.resolve(obj))\n\nconst passwd = process.env.ENCRYPTION_PWD\nconst algo = 'aes-192-cbc'\nconst key = crypto.scryptSync(String(passwd), 'salt', 24)\nconst iv = Buffer.alloc(16, 0)\n\nexport function encrypt (text) {\n  const cipher = crypto.createCipheriv(algo, key, iv)\n  let encrypted = cipher.update(text, 'utf8', 'hex')\n  encrypted += cipher.final('hex')\n  return encrypted\n}\n\nexport function decrypt (cipherText) {\n  console.log('decrypt(%s)', cipherText)\n  const decipher = crypto.createDecipheriv(algo, key, iv)\n  let decrypted = decipher.update(cipherText, 'hex', 'utf8')\n  decrypted += decipher.final('utf8')\n  return decrypted\n}\n\nexport function hash (data) {\n  return crypto\n    .createHash('sha1')\n    .update(data)\n    .digest('hex')\n}\n\nexport function uuid () {\n  // return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>\n  //   (c ^ (crypto.randomBytes(16)[0] & (15 >> (c / 4)))).toString(16)\n  // );\n  return nanoid()\n}\n\nexport function makeArray (v) {\n  return Array.isArray(v) ? v : [v]\n}\n\nexport function makeObject (prop) {\n  if (Array.isArray(prop)) {\n    return prop.reduce((p, c) => ({ ...p, ...c }))\n  }\n  return prop\n}\n\n/**\n *\n * @param {Promise<{\n * ok:()=>any,\n *\n * }} promise\n * @returns\n */\nexport function async (promise) {\n  return promise\n    .then(result => ({\n      ok: true,\n      object: result,\n      asObject: () => makeObject(result),\n      asArray: () => makeArray(result)\n    }))\n    .catch(error => {\n      console.error(error)\n      return Promise.resolve({ ok: false, error })\n    })\n}\n","import crypto from 'crypto'\nimport { urlAlphabet } from './url-alphabet/index.js'\nconst POOL_SIZE_MULTIPLIER = 128\nlet pool, poolOffset\nlet fillPool = bytes => {\n  if (!pool || pool.length < bytes) {\n    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)\n    crypto.randomFillSync(pool)\n    poolOffset = 0\n  } else if (poolOffset + bytes > pool.length) {\n    crypto.randomFillSync(pool)\n    poolOffset = 0\n  }\n  poolOffset += bytes\n}\nlet random = bytes => {\n  fillPool((bytes -= 0))\n  return pool.subarray(poolOffset - bytes, poolOffset)\n}\nlet customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1\n  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let i = step\n      while (i--) {\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nlet customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nlet nanoid = (size = 21) => {\n  fillPool((size -= 0))\n  let id = ''\n  for (let i = poolOffset - size; i < poolOffset; i++) {\n    id += urlAlphabet[pool[i] & 63]\n  }\n  return id\n}\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n","let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nexport { urlAlphabet }\n"],"sourceRoot":""}